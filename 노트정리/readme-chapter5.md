##5장


트랜잭션이랑 더 이상 나눌 수 없느 ㄴ단위 작업.
중간예 예외가 발생해서 작업을 완료할 수 없다면 아예 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다.

트랜ㅌ잭션 경계 설정
- DB는 그 자체로 완벽한 트랜잭션을 지원한다.
- 예를들어 계좌이체 작업은
  - 출금계좌의 잔고는 이체금액만큼 줄어들고, 입금계좌에는 이체금액만큼 증가돼야 한다.
  - 이때  DB에 두번 요청을 보낸다
- 모든 SQL 이 성공하기전에 문제가 발생한 경우 트랜잭션 롤백, 이전 작업 포함 모든 처리작업을 취소시켜야한다.
- 반대로 여러개의 SQL 을 하나의 트랜잭션으로 처리하는 경우, 모두 성공 적으로 수행됬을 시에 작업을 확정 (트랜잭션 커밋)을 해주어야 한다.

JDBC 트랜잭션의 트랜잭션 경계설정
- setAutoCommit(false) 로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 트랜잭션의 경계설정 이라고 한다. 트랜잭션의 경계는 하나의 Connection 이 만들어지고 닫히는 범위 안에 존재 한다는 점도 기억해두자. 이렇게 하나의 DB커넥션 안에서 만들어지는 트랜잭션을 로컬 트랜잭션 이라고도 한다.

기술과 환겨엥 종속되는 트랜잭션 종속코드.
- 한갱 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는건 JDBC의 Connection을 이요한 로컬 트랜잭션으로는 불가능하다.
- 별도의 트랜잭션 관리자를 통해 트랝개션을 관리하는 글로벌 트랜잭션 방식을 사용해야한다. 글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다. 또 JMS 와 같은 트랜잭션 기능을 지원하는 서비스도 트랜잭션에 참여시킬 수 있다.
- JTA : Java Transaction API
  - JTA를 이용해 여러개의 트랜잭션을 관리할 수 있다.

스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 PlatformTransaction MAnager다.
JDBC의 로컬 트랜잭션을 이용한다면 PlatformTransactionManager를 구현한 -DataSourceTransactionManager를 사용하면 된다. 사용할 DB의 DataSource를 생성자 파라미터로 넣으면서 DataSourceTransactionManager의 오브젝트를 만든다.

JDBC를 이용하는 경우에는 먼저 Connection 을 생성하고 나서 트랜잭션을 시작했다. 하지만
- PlatformTransactionManger에서 는 트랜잭션을 가져오는 요청인 getTransaction()메소드를 호출하기만 하면 된다.
- 필요에 따라 트랜잭션 매니저가 DB커넥션을 가져오는 작업도 같이 수행해주기 때문이다. 여기서 트랜잭션을 가져온다는 것은 일단 트랜잭션을 시작한다는 의미로 생각하자
- 모든 작업을 완료 후 commit()을, 예와가 발생 할 시에는 rollback() 메소드를 부른다.


###5.3. 서비스 추상화와 단일 책임 원칙


수직, 수평 계층 구조와 의존 관계
- 5.2.장에서 다룬 내용처럼 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
  - UserDao 와 UserService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다.
  - 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리한것을 같은 계층에서 수평적인 분리라고 볼 수 있다.
- 트랜잭션의 추상화는 이와는 조금 다르다.
  - 애플리케이션의 비즈니스 로직과 그 하위에 서 동작하는 로웁레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.
  - 수직적 계층 구조
- 스프링의 DI의 역할
  - 애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮게 한다.
  - 서로 영향을 주지 않고 자유롭게 확장될 수 잇는 구조를 만들 수 잇는데는 스프링의 DI가 중요한 역할을 하고 있다.
  - DI 의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

단일 책임 원칙
- 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다.
- 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수 있다.
- 단일 책임의 원칙을 통해 코드 사이의 결합을 낮출 수 있다.



테스트 대역의 종류와 특징
- 테스트 대용으로 사용되는 특별한 오브젝트들이 있다.
- 대부분 테스트 대상인 오브젝트의 의존 오브젝트가 되는 것들이다.
- DataSource, Dao, MailSende과 같은 인터페이스를 구현한 것들이다.
- 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있또록 사용하는 이런 오브젝트를 통틀어서 테스트 대역이라고 부른다.
- 대표적인 테스트 대역은 테스트 스텁 test stub이다.
- 테스트 스텁은 테스트 코드 내부에서 간접적으로 사용된다.
- 따라서 DI ㄹ를 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.
- ㅁ리턴 값이 있는 메소드를 이용하는 경우에는 결과가 필요하다. 이럴땐 스텁에 미리 테스트중에 필요한 정보를 리턴 해주도록 만들 수 있고, 어떠 ㄴ스텁은 강제로 예외를 발생시키게 할 수 있다.

목 오브젝트 mock obejt
- 테스트 대상의 간접적인 출력결ㄹ과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 특별히 설계된 목 오브젝트를 사용해야ㅎ 한다.
- 목 오브젝트는 스텁 처럼 테스트 오브젝트가 정상적으로 실행되도록 돠와주면서, 테스트 오브젝트와 자신의 사이에서 일어나는 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용할 수 있게 해준다.


###5.5 정리


5장에서는 비즈니스 로직을 담은 UserService 클래스를 만들고 트랜잭션을 적용하면서 스프링의 서비스 추상화에 대해 살펴보았다.
여기서 다른 주요한 내용은 다음과 같다.
- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다.
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI 를 잘 활용해서 결합도를 낮춰줘야한다.
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.
- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO 에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
- 자바에서 사용되는 트랜잭션 API 의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함꼐 변경돼야 한다.
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하느 ㄴ특정 기술에 대한 강한 결합을 만들어낸다.
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API 를 가진 추상화 계층을 도입한다.
- 서비스 추상화는 테스트하기 어려운 javamail 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
- 테스트 대상이 사용하는 의존오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
- 테스트 대역은 테스트 대상 오브젝트 가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
- 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.

