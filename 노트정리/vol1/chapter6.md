# 6장 AOP

- AOP 는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나다.
- AOP 는 스프링의 기술 중에서 가장 이해하기 힘든 난해한 용어와 개념을 가진 기술로 악명이 높다.
- 스프링에 적용된 가장 인기 있는 AOP 의 적용 대상은 바로 선언적 트랜잭션 기능이다.

## 6.1. 트랜잭션 코드의 분리

### 트랜잭션 경계설정 코드 분리의 장점, 수고스러운 만큼 얻을 수 있는 커다란 장점

- 첫번재 장점
    - 비즈니스 로직을 담당하고 있는 UserServiceImple의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 트랜잭션 적용이 필요한지도 신경쓰지 않아도 된다.
- 두번째 장점
    - 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.

## 6.2. 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.
- 고립된 단위테스트를 활용한다.
- 단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메소드를 단위로 볼 수 있다.
- 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다. 어쨋든 단위 테스트라는 용어를 사용할 대는 그 의미를 명확히 할 필요가 있다.
- 이 책에서는 앞으로 upgradelevels() 테스트처럼 "테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것"을 단위
  테스트라고 부르겠다.
- 반면에 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트는 통합 테스트라고 부르겠다.
    - 통합 테스트란 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는 것이라고 보면 된다.
    - 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브젝트를 테스트하는 것도 통합 테스트다.

### 단위 테스트와 통합 테스트 중에서 선택방법

- 항상 단위 테스트를 먼저 고려한다.
- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
    - 단위테스트는 테스트 작성도 간단하고 실행속도도 빠르며 테스트 대상 외의 코드나 환경으로부터 테스트 결과에 영향을 받지도 않기 때문에 가장 빠른 시간에 효과적인 테스트를 작성하기에 유리하다.
- 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
- 단위 테스트로 만들기가 어려운 코드도 있다.
- 대표적인게 DAO. DAO 는 로직을 수행하는 인터페이스와 같은 역할을 한다.
    - DAO는 작성한다고 해도 가치가 없는 경우가 대부분이다.
    - DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    - DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인을 하는등의 부가적인 작업이 필요하다.
- DAO 테스트는 DB라는 외부 리소스를 사용하기 때문에 통합 테스트로 분류된다.
    - 하지만 코드에서 보자면 하나의 기능 단위를 테스트하는 것이기도 하다.
    - DAO를 테스트르 ㄹ통해 충분히 검증해두면, DAO 를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다.
    - 이후에 실제 DAO 와 연동햇을 때도 바르게 동작하리라고 확신할 수 있다.
    - 물론 가가각의 단위 테스트가 성고앻ㅆ더라도 여러개의 단위를 연결해서 테스트하면 오류가 발생할 수도 잇다.
    - 하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가발생할 화ㄱ률도 줄어들고 발생한다고 하더라도 쉽게 처리할 수 있다.
- 여러 개의 단위가 의존관게를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    - 다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
- 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해 본다.
    - 이때도 통합테스트에 참여하는 코드중에서 가능한 많은 부분을 미리 단위 테스트로 검증해두는게 유리하다.
- 스프링 테스트 컨텍스트 플에이믐워크를 이용하는 테스트는 통합 테스트다.
    - 가능하면 스프링의 지원없이 직접 코드 레벨의 DI 를 사용하면서 단위 테스트를 하는 게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종
      있다.
    - 이럴 땐 스프링 테스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.

> 테스트 코드를 작성한 이후에 만든드는 경우에도 가능한 한 빨리 작성하도록 해야한다.
>
> 코드를 만들고 오랜 시간이 지난 뒤에 작성하는 테스트는 테스트 대상 코드 에 대한 이해가 떨어지기 때문에 불안전해지기 쉽고 작성하기도 번거롭다.

### 목 프레임워크 Mockito

- Mockito 는 다음의 네 단계를 거쳐서 사용하면 된다. 두 번째와 네 번째는 각각 필요한 경우에만 사용할 수 있다.

1. 인터페이스를 이용해 목 오브젝트를 만든다.
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
3. 테스트 대상 오브젝트에 DI 를 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됏는지 어떤 값을 가지고 몇번 호출됐는지를 검증한다.

### 6.3.다이내믹 프록시와 팩토리 빈

- 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같을 역할을 한다고 해서 프록시라고 부른다.
    - 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체 라고 부른다.
- 프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.
- 프록시는 사용 목적에 따라 두 가지로 구분할 수 있다.
    - 첫째는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다.
    - 두 번째는 타깃에 부가적인 기능을 부여해주기 위해서다.
    - 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일 하지만, 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.

### 데코레이터 패턴

- 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
- 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.

### 프록시 패턴

- 일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분 할 필요가 있다.
    - 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다면,
    - 후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
    - 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트르 생성하지 않는 편이 좋다.
- 이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다. 구조적으로 보자면 프록시와 데코레이터는 유사하다.
- 다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있느 ㄴ경우가 많다.

> 정리 : 프록시의 목적은 두가지로 나눌 수 있다.
>> 기능의 부가
>
>> 접근 제어

## 6.3.2. 다이내믹 프록시

- 자바에는 java.lang.reflect 패키지안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다. 기본적인 아이디어는 목 프레임워크와 비슷하다.

### 프록시를 만들기가 번거로운 이유

- 첫째는 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다는 점이다.
    - 부가기능이 필요없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
    - 복잡하진 않지만 인터페이스의 메소드가 많아지고 다양해지면 상당히 부담스러운 작업이 될 것이다.
    - 또, 타깃 인터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해줘야 한다는 부담도 있다.
- 두번째 문제점은 부가기능 코드가 중복될 가능성이 많다는 점이다.

### 리플렉션

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.

### 다이내믹 프록시를 만들어주는 팩토리 빈

- Proxy 의 newProxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다.
- 대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수가 있다.

### 6.3.5. 프록시 팩토리 빈 방식의 장점과 한계

- 다이내믹 프록시를 생성해주는 팩토리 빈을 사용하는 방법의 장점
    - 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있기 때문이다.

### 프록시 팩토리 빈 방식의 장점

앞에서 데코레이터 패턴이 적용된 프록시를 사용하면 많은 장점이 있음에도 적극적으로 활용되지 못하는 데는 두 가지 문제점이 있다고 설명했다.

- 첫째는 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 한다는 번거로움이고,
- 둘째는 부가적인 기능이 여러 메소드에 반복적으로 나타나게 돼서 코드 중복의 문제가 발생한다는 점이다.

지금까지 살펴본 프록시 팩토리 빈은 이 두가지 문제를 해결해준다.

- 다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
- 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다.

### 프록시 팩토리 빈의 한계

- 프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다. 하나의 클래스 안에 존재하는 여러개의 메소드에 부가기능을 한 번에 제공하는 건 어렵지 않게 가능했따.
- 하지만 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 지금까지 살펴본 방법으로는 불가능하다.
    - 하나의 타깃 오브젝트에만 부여되는 부가기능이라면 상관없겠지만,
    - 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 잇다면 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.

> 어드바이스 : 타깃이 필요 없는 순수한 부가기능을 제공하는 오브젝트

> 포인트컷 : 부가기능 적용 대상 메소드 선정 알고리즘을 담은 오브젝트

### 어드바이저 = 포인트컷 + 어드바이스

포인트컷의 표현식

``` java
execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...)
```

***포인트컷 정규식은 클래스가 아니라 타입으로 적용된다.

## AOP Aspect Oriented Programming / 애스팩트 지향 프로그래밍.

## AOP 적용기술

- 프록시를 이용한 AOP
    - 스프링은 IoC/DI 컨테이너와 다이내믹 프록시, 데코레이터 패턴, 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술을 조합해 AOP를 지원하고 있다.
    - 그중 가장 핵심은 프록시를 이용했다는 것이다.
    - 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만들었다.
    - 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고 있는 게 바로 프록시다.
    - 그래서 스프링 AOP 는 프록시 방식의 AOP 라고 할 수 있다.

### 바이트코드 생성과 조작을 통한 AOP

- Aspect J 는 바이트코드 조작해서 타깃 오브젝트를 수정하거나 조작한다.
- AspectJ 는 AspectJ 같은 고급 AOP 기술이다.

### AOP 용어

- 타깃
    - 타깃의 부가기능을 부여할 대상
    - 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.
- 어드바이스
    - 타깃에게 제공할 부가기능을 담은 모듈
    - 오브젝트레벨과 메소드 레벨에서 가능
    - 메소드 호출 과정 전반, 또는 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.
- 조인 포인트
    - 어드바이스가 적용될 수 있는 위치를 말한다.
    - 스프링의 프록시 AOP 에서 조인 포인트는 메소드의 실행단계 뿐이다.
- 포인트컷
    - 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다.
    - 스프링 AOP 의 조인 포인트는 메소드의 실행이므로 스프링의 포인트 컷은 메소드를 선정하는 기능을 갖고 있다.
- 프록시
    - 클라이언트와 타깃 사이에 안보이게 존재하면서 부가기능을 제공.
    - DI 를 통해 타깃 대신 클라이언트에게 주입되며
    - 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임하고 그 과정에서 부가기능을 부여한다.
    - 스프링은 프록시를 이용해 AOP를 지원한다.
- 어드바이저
    - 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다.
- 애스팩트
    - OOP 의 클래스와 마찬가지로 애스팩트는 AOP 의 기본 모듈이다.
    - 한개 또는 그 이상의 포인트 컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.

# AOP 네임스페이스

> 스프링의 프록시 방식 AOP 를 적용하려면 최소한 네 가지 빈을 등록해야하며 어드바이스를 제외하면 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준다.
> 
 
- 자동 프록시 생성기
    - 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다.
    - 다른 빈을 DI 하지도 않고 자신도 DI 되지 않으며 독립적으로 존재한다.
    - 따라서 id도 굳이 필요하지 않다.
- 어드바이스
    - 부가기능을 구현한 클래스를 빈으로 등록한다.
    - TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.
- 포인트컷
- 어드바이저

## 6.6.3. 포인트 컷과 트랜잭션 속성의 전용 전략

- 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈이름을 사용한다.
    - 쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는 게 좋다. 조회의 경우에는 읽기전용으로 트랝개션 속성을 설정해두면 그만큼의 성능의 향상을 가져올 수 잇다.
    - 트랜잭션 포인트컷 표현식에는 메소드나 파라미터, 예외에 대한 피턴을 정의하지 않는게 바람직하다.
    - 가능하면 클래스보다는 인터페이스 타입을 기준으로 타입패턴을 적용하는 것이 좋다.
    - 인터페이스는 클래스에 비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문이다.
- 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
- (주의사항) 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.
    - 프록시 방식의 AOP에서는 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다.( 호출시 프록시를 통과하지 않고 내부에서만 적용되기 때문에)

### @Transaction 대체 정책

- 스프링은 @Transcaitonal 을 적용할 때 4단계의 대체정 책을 이용하게 해준다.
    - 타깃 메소드
    - 타깃 클래스
    - 선언 메소드
    - 선언 타입
- 순서에 따라서 @Transactional 이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.
- 기본적으로 @Transactional 적용 대상은 클라이언트가 사용하는 인터페이스가 정의한 메소드이므로 @Transactional도 타깃 클래스 보다는 인터페이스에 두는게 바람직하다.
- 하지만 인터페이스를 사용하는 프록시 방식의 AOP 가 아닌 트랜잭션으로 젹용하면 인터페이스에 정의한 @Transactional은 무시되기 때문제 안전하게 타깃 클래스에 @Transcaitonal을 두는 방법을
  권장한다.
 

> ***롤백 테스트는 복잡한 DB 쓰기 및 수정 관련 테스트를 수행하고나서 DB 상태를 원상복귀 시켜놓을 수 있기에 유용하다.
> 

### 6.9. 정리

6장에서는 트랜잭션 경계설정 기능을 성격이 다른 비즈니스 로직 클래스에서 분리하고 유연하게 적용할 수 있는 방법을 찾아보면서 애플리케이션에 산재해서 나타나는 부가기능을 모듈화할 수 있는 AOP 기술을 알아봤다.

여기서 다룬 주요한 내용은 다음과 같다.

- 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI 의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게 분리된 트랜잭션 부가기능을 만들 수
  있다.
- 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.
- 목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수 있다.
- DI 를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
- 번거로운 프록시 클래스 작성은 JDK 의 다이내믹 프록시를 이용하면 간단하게 만들 수 있다.
- 다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다.
- 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
- 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용할 수 있다.
- 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
- 포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.
- AOP 는 OOP 만으로 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
- 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는데 사용할 수 있는 전용 태그를 제공한다.
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 @Transactional 애토테이션을 사용하는 방법이 있다.
- @Transactional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다. 































